# Two Subs

Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.

You may assume that each input would have exactly one solution, and you may not use the same element twice.

You can return the answer in any order.

 

## Example 1:
```js

Input: nums = [2,7,11,15], target = 9
Output: [0,1]
Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].
```
## Example 2:
```js

Input: nums = [3,2,4], target = 6
Output: [1,2]
Example 3:

Input: nums = [3,3], target = 6
Output: [0,1]
 
```

## Constraints:
```js

2 <= nums.length <= 104
-109 <= nums[i] <= 109
-109 <= target <= 109
Only one valid answer exists.
 ```


### Follow-up: Can you come up with an algorithm that is less than O(n2) time complexity?

in this problem, the challenge lies in solving the problem without producing an algorithm with  O(n2) time complexity.
in this case the basic solution i produced consist of this disavantadge, where as i produce an algorithm with nested loop with the threshold of the length of the array.

one of the solution we can make use to achieve better time complexity, is using a hash data structure where as the time complexity to get a certain value inside it is 0(1).

one of the method we can use to utilize hash in this problem is by saving the value of the target - array[i] as to save the value that can make the current value of array in the loop equal to the target

below is the implementation:

```js
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
var twoSum = function(nums, target) {
    let check = {};
    for (let i = 0 ; i<= nums.length -1 ; i++ ){
        if( check[target - nums[i]] !== undefined){
            return [check[target - nums[i]],i]
        }else{
             check[nums[i]] = i
        }
    }
};

```
